{"backend_state":"ready","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.11.6"}},"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"63d608","input":"import sympy as sm\nsm.init_printing(use_latex='mathjax')","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:17.366259Z","iopub.status.busy":"2023-06-28T09:21:17.365821Z","iopub.status.idle":"2023-06-28T09:21:17.729412Z","shell.execute_reply":"2023-06-28T09:21:17.728519Z"}},"pos":0,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"308e20","input":"import sympy.physics.mechanics as me","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.366211Z","iopub.status.busy":"2023-06-28T09:21:18.365626Z","iopub.status.idle":"2023-06-28T09:21:18.376299Z","shell.execute_reply":"2023-06-28T09:21:18.375481Z"}},"pos":25,"type":"cell"}
{"cell_type":"code","exec_count":11,"id":"367ddf","input":"class ReferenceFrame(me.ReferenceFrame):\n\n    def __init__(self, *args, **kwargs):\n\n        kwargs.pop('latexs', None)\n\n        lab = args[0].lower()\n        tex = r'\\hat{{{}}}_{}'\n\n        super(ReferenceFrame, self).__init__(\n            *args,\n            latexs=(tex.format(lab, 'x'),\n            tex.format(lab, 'y'),\n            tex.format(lab, 'z')),\n            **kwargs)\n        \nme.ReferenceFrame = ReferenceFrame","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.379296Z","iopub.status.busy":"2023-06-28T09:21:18.378917Z","iopub.status.idle":"2023-06-28T09:21:18.384732Z","shell.execute_reply":"2023-06-28T09:21:18.383911Z"}},"pos":27,"type":"cell"}
{"cell_type":"code","exec_count":12,"id":"ffd058","input":"N = me.ReferenceFrame('N')","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.387746Z","iopub.status.busy":"2023-06-28T09:21:18.387500Z","iopub.status.idle":"2023-06-28T09:21:18.391716Z","shell.execute_reply":"2023-06-28T09:21:18.390915Z"}},"pos":29,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"9508a2","input":"N.x, N.y, N.z","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.394796Z","iopub.status.busy":"2023-06-28T09:21:18.394551Z","iopub.status.idle":"2023-06-28T09:21:18.400651Z","shell.execute_reply":"2023-06-28T09:21:18.399844Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left( \\hat{n}_x, \\  \\hat{n}_y, \\  \\hat{n}_z\\right)$","text/plain":"(n_x, n_y, n_z)"},"exec_count":13,"output_type":"execute_result"}},"pos":31,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"bbba84","input":"A = me.ReferenceFrame('A')\nB = me.ReferenceFrame('B')\n\nN, A, B","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.404814Z","iopub.status.busy":"2023-06-28T09:21:18.404347Z","iopub.status.idle":"2023-06-28T09:21:18.410714Z","shell.execute_reply":"2023-06-28T09:21:18.409912Z"}},"output":{"0":{"data":{"text/plain":"(N, A, B)"},"exec_count":14,"output_type":"execute_result"}},"pos":33,"type":"cell"}
{"cell_type":"code","exec_count":15,"id":"680da1","input":"A_C_N","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.414606Z","iopub.status.busy":"2023-06-28T09:21:18.414027Z","iopub.status.idle":"2023-06-28T09:21:18.421126Z","shell.execute_reply":"2023-06-28T09:21:18.420325Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(θ)   sin(θ)  0⎤\n⎢                  ⎥\n⎢-sin(θ)  cos(θ)  0⎥\n⎢                  ⎥\n⎣   0       0     1⎦"},"exec_count":15,"output_type":"execute_result"}},"pos":35,"type":"cell"}
{"cell_type":"code","exec_count":16,"id":"e77aac","input":"N.orient_explicit(A, A_C_N)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.425153Z","iopub.status.busy":"2023-06-28T09:21:18.424700Z","iopub.status.idle":"2023-06-28T09:21:18.430165Z","shell.execute_reply":"2023-06-28T09:21:18.429439Z"}},"pos":36,"type":"cell"}
{"cell_type":"code","exec_count":17,"id":"2a810f","input":"A.dcm(N)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.433714Z","iopub.status.busy":"2023-06-28T09:21:18.433299Z","iopub.status.idle":"2023-06-28T09:21:18.442295Z","shell.execute_reply":"2023-06-28T09:21:18.441595Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(θ)   sin(θ)  0⎤\n⎢                  ⎥\n⎢-sin(θ)  cos(θ)  0⎥\n⎢                  ⎥\n⎣   0       0     1⎦"},"exec_count":17,"output_type":"execute_result"}},"pos":38,"type":"cell"}
{"cell_type":"code","exec_count":18,"id":"70fac3","input":"N.dcm(A)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.445312Z","iopub.status.busy":"2023-06-28T09:21:18.444813Z","iopub.status.idle":"2023-06-28T09:21:18.451945Z","shell.execute_reply":"2023-06-28T09:21:18.451157Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & - \\sin{\\left(\\theta \\right)} & 0\\\\\\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(θ)  -sin(θ)  0⎤\n⎢                  ⎥\n⎢sin(θ)  cos(θ)   0⎥\n⎢                  ⎥\n⎣  0        0     1⎦"},"exec_count":18,"output_type":"execute_result"}},"pos":39,"type":"cell"}
{"cell_type":"code","exec_count":19,"id":"6f250a","input":"B.orient_axis(A, alpha, A.z)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.471204Z","iopub.status.busy":"2023-06-28T09:21:18.470965Z","iopub.status.idle":"2023-06-28T09:21:18.477702Z","shell.execute_reply":"2023-06-28T09:21:18.476912Z"}},"pos":41,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"a964e6","input":"theta = sm.symbols('theta')\n\nA_C_N = sm.Matrix([ [sm.cos(theta), sm.sin(theta), 0],\n                    [-sm.sin(theta), sm.cos(theta), 0],\n                    [0, 0, 1] ])\nA_C_N","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:17.733146Z","iopub.status.busy":"2023-06-28T09:21:17.732824Z","iopub.status.idle":"2023-06-28T09:21:17.986380Z","shell.execute_reply":"2023-06-28T09:21:17.985502Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(θ)   sin(θ)  0⎤\n⎢                  ⎥\n⎢-sin(θ)  cos(θ)  0⎥\n⎢                  ⎥\n⎣   0       0     1⎦"},"exec_count":2,"output_type":"execute_result"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":20,"id":"26ea94","input":"B.dcm(A)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.480861Z","iopub.status.busy":"2023-06-28T09:21:18.480614Z","iopub.status.idle":"2023-06-28T09:21:18.487662Z","shell.execute_reply":"2023-06-28T09:21:18.486887Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\alpha \\right)} & \\sin{\\left(\\alpha \\right)} & 0\\\\- \\sin{\\left(\\alpha \\right)} & \\cos{\\left(\\alpha \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(α)   sin(α)  0⎤\n⎢                  ⎥\n⎢-sin(α)  cos(α)  0⎥\n⎢                  ⎥\n⎣   0       0     1⎦"},"exec_count":20,"output_type":"execute_result"}},"pos":42,"type":"cell"}
{"cell_type":"code","exec_count":21,"id":"b2bb85","input":"A.dcm(B)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.491314Z","iopub.status.busy":"2023-06-28T09:21:18.491076Z","iopub.status.idle":"2023-06-28T09:21:18.498328Z","shell.execute_reply":"2023-06-28T09:21:18.497495Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\alpha \\right)} & - \\sin{\\left(\\alpha \\right)} & 0\\\\\\sin{\\left(\\alpha \\right)} & \\cos{\\left(\\alpha \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(α)  -sin(α)  0⎤\n⎢                  ⎥\n⎢sin(α)  cos(α)   0⎥\n⎢                  ⎥\n⎣  0        0     1⎦"},"exec_count":21,"output_type":"execute_result"}},"pos":43,"type":"cell"}
{"cell_type":"code","exec_count":22,"id":"79ab70","input":"sm.trigsimp(B.dcm(A)*A.dcm(N))","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.502086Z","iopub.status.busy":"2023-06-28T09:21:18.501840Z","iopub.status.idle":"2023-06-28T09:21:18.663653Z","shell.execute_reply":"2023-06-28T09:21:18.662813Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\alpha + \\theta \\right)} & \\sin{\\left(\\alpha + \\theta \\right)} & 0\\\\- \\sin{\\left(\\alpha + \\theta \\right)} & \\cos{\\left(\\alpha + \\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(α + θ)   sin(α + θ)  0⎤\n⎢                          ⎥\n⎢-sin(α + θ)  cos(α + θ)  0⎥\n⎢                          ⎥\n⎣     0           0       1⎦"},"exec_count":22,"output_type":"execute_result"}},"pos":44,"type":"cell"}
{"cell_type":"code","exec_count":23,"id":"0fa0a6","input":"sm.trigsimp(B.dcm(N))","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.666727Z","iopub.status.busy":"2023-06-28T09:21:18.666471Z","iopub.status.idle":"2023-06-28T09:21:18.827089Z","shell.execute_reply":"2023-06-28T09:21:18.826247Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\alpha + \\theta \\right)} & \\sin{\\left(\\alpha + \\theta \\right)} & 0\\\\- \\sin{\\left(\\alpha + \\theta \\right)} & \\cos{\\left(\\alpha + \\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(α + θ)   sin(α + θ)  0⎤\n⎢                          ⎥\n⎢-sin(α + θ)  cos(α + θ)  0⎥\n⎢                          ⎥\n⎣     0           0       1⎦"},"exec_count":23,"output_type":"execute_result"}},"pos":45,"type":"cell"}
{"cell_type":"code","exec_count":24,"id":"7d5893","input":"sm.trigsimp(me.dot(B.x, N.x))","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.830339Z","iopub.status.busy":"2023-06-28T09:21:18.830095Z","iopub.status.idle":"2023-06-28T09:21:18.883610Z","shell.execute_reply":"2023-06-28T09:21:18.882771Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\cos{\\left(\\alpha + \\theta \\right)}$","text/plain":"cos(α + θ)"},"exec_count":24,"output_type":"execute_result"}},"pos":46,"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"0c3a7e","input":"psi = sm.symbols('psi')\n\nA = me.ReferenceFrame('A')\nB = me.ReferenceFrame('B')\n\nB.orient_axis(A, psi, A.z)\n\nB.dcm(A)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.915371Z","iopub.status.busy":"2023-06-28T09:21:18.914894Z","iopub.status.idle":"2023-06-28T09:21:18.927213Z","shell.execute_reply":"2023-06-28T09:21:18.926377Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\psi \\right)} & \\sin{\\left(\\psi \\right)} & 0\\\\- \\sin{\\left(\\psi \\right)} & \\cos{\\left(\\psi \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(ψ)   sin(ψ)  0⎤\n⎢                  ⎥\n⎢-sin(ψ)  cos(ψ)  0⎥\n⎢                  ⎥\n⎣   0       0     1⎦"},"exec_count":25,"output_type":"execute_result"}},"pos":49,"type":"cell"}
{"cell_type":"code","exec_count":26,"id":"ac8feb","input":"theta = sm.symbols('theta')\n\nC = me.ReferenceFrame('C')\n\nC.orient_axis(B, theta, B.x)\n\nC.dcm(B)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.931086Z","iopub.status.busy":"2023-06-28T09:21:18.930624Z","iopub.status.idle":"2023-06-28T09:21:18.942093Z","shell.execute_reply":"2023-06-28T09:21:18.941244Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)}\\\\0 & - \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)}\\end{matrix}\\right]$","text/plain":"⎡1     0       0   ⎤\n⎢                  ⎥\n⎢0  cos(θ)   sin(θ)⎥\n⎢                  ⎥\n⎣0  -sin(θ)  cos(θ)⎦"},"exec_count":26,"output_type":"execute_result"}},"pos":51,"type":"cell"}
{"cell_type":"code","exec_count":27,"id":"c146cc","input":"phi = sm.symbols('varphi')\n\nD = me.ReferenceFrame('D')\n\nD.orient_axis(C, phi, C.y)\n\nD.dcm(C)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.945563Z","iopub.status.busy":"2023-06-28T09:21:18.945122Z","iopub.status.idle":"2023-06-28T09:21:18.958562Z","shell.execute_reply":"2023-06-28T09:21:18.957751Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\varphi \\right)} & 0 & - \\sin{\\left(\\varphi \\right)}\\\\0 & 1 & 0\\\\\\sin{\\left(\\varphi \\right)} & 0 & \\cos{\\left(\\varphi \\right)}\\end{matrix}\\right]$","text/plain":"⎡cos(varphi)  0  -sin(varphi)⎤\n⎢                            ⎥\n⎢     0       1       0      ⎥\n⎢                            ⎥\n⎣sin(varphi)  0  cos(varphi) ⎦"},"exec_count":27,"output_type":"execute_result"}},"pos":53,"type":"cell"}
{"cell_type":"code","exec_count":28,"id":"426abe","input":"D.dcm(A)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.961824Z","iopub.status.busy":"2023-06-28T09:21:18.961365Z","iopub.status.idle":"2023-06-28T09:21:18.984059Z","shell.execute_reply":"2023-06-28T09:21:18.983241Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}- \\sin{\\left(\\psi \\right)} \\sin{\\left(\\theta \\right)} \\sin{\\left(\\varphi \\right)} + \\cos{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} & \\sin{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} + \\sin{\\left(\\theta \\right)} \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\psi \\right)} & - \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\theta \\right)}\\\\- \\sin{\\left(\\psi \\right)} \\cos{\\left(\\theta \\right)} & \\cos{\\left(\\psi \\right)} \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)}\\\\\\sin{\\left(\\psi \\right)} \\sin{\\left(\\theta \\right)} \\cos{\\left(\\varphi \\right)} + \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\psi \\right)} & \\sin{\\left(\\psi \\right)} \\sin{\\left(\\varphi \\right)} - \\sin{\\left(\\theta \\right)} \\cos{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} & \\cos{\\left(\\theta \\right)} \\cos{\\left(\\varphi \\right)}\\end{matrix}\\right]$","text/plain":"⎡-sin(ψ)⋅sin(θ)⋅sin(varphi) + cos(ψ)⋅cos(varphi)  sin(ψ)⋅cos(varphi) + sin(θ)⋅\n⎢                                                                             \n⎢                -sin(ψ)⋅cos(θ)                                   cos(ψ)⋅cos(θ\n⎢                                                                             \n⎣sin(ψ)⋅sin(θ)⋅cos(varphi) + sin(varphi)⋅cos(ψ)   sin(ψ)⋅sin(varphi) - sin(θ)⋅\n\nsin(varphi)⋅cos(ψ)  -sin(varphi)⋅cos(θ)⎤\n                                       ⎥\n)                         sin(θ)       ⎥\n                                       ⎥\ncos(ψ)⋅cos(varphi)  cos(θ)⋅cos(varphi) ⎦"},"exec_count":28,"output_type":"execute_result"}},"pos":55,"type":"cell"}
{"cell_type":"code","exec_count":29,"id":"ac0db2","input":"A = me.ReferenceFrame('A')\nD = me.ReferenceFrame('D')\n\nD.orient_body_fixed(A, (psi, theta, phi), 'zxy')\n\nD.dcm(A)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.987389Z","iopub.status.busy":"2023-06-28T09:21:18.986913Z","iopub.status.idle":"2023-06-28T09:21:19.075456Z","shell.execute_reply":"2023-06-28T09:21:19.074625Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}- \\sin{\\left(\\psi \\right)} \\sin{\\left(\\theta \\right)} \\sin{\\left(\\varphi \\right)} + \\cos{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} & \\sin{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} + \\sin{\\left(\\theta \\right)} \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\psi \\right)} & - \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\theta \\right)}\\\\- \\sin{\\left(\\psi \\right)} \\cos{\\left(\\theta \\right)} & \\cos{\\left(\\psi \\right)} \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)}\\\\\\sin{\\left(\\psi \\right)} \\sin{\\left(\\theta \\right)} \\cos{\\left(\\varphi \\right)} + \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\psi \\right)} & \\sin{\\left(\\psi \\right)} \\sin{\\left(\\varphi \\right)} - \\sin{\\left(\\theta \\right)} \\cos{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} & \\cos{\\left(\\theta \\right)} \\cos{\\left(\\varphi \\right)}\\end{matrix}\\right]$","text/plain":"⎡-sin(ψ)⋅sin(θ)⋅sin(varphi) + cos(ψ)⋅cos(varphi)  sin(ψ)⋅cos(varphi) + sin(θ)⋅\n⎢                                                                             \n⎢                -sin(ψ)⋅cos(θ)                                   cos(ψ)⋅cos(θ\n⎢                                                                             \n⎣sin(ψ)⋅sin(θ)⋅cos(varphi) + sin(varphi)⋅cos(ψ)   sin(ψ)⋅sin(varphi) - sin(θ)⋅\n\nsin(varphi)⋅cos(ψ)  -sin(varphi)⋅cos(θ)⎤\n                                       ⎥\n)                         sin(θ)       ⎥\n                                       ⎥\ncos(ψ)⋅cos(varphi)  cos(θ)⋅cos(varphi) ⎦"},"exec_count":29,"output_type":"execute_result"}},"pos":57,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"537158","input":"A_C_N.inv()","output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}- \\frac{\\sin^{2}{\\left(\\theta \\right)}}{\\cos{\\left(\\theta \\right)}} + \\frac{1}{\\cos{\\left(\\theta \\right)}} & - \\sin{\\left(\\theta \\right)} & 0\\\\\\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡     2                        ⎤\n⎢  sin (θ)     1               ⎥\n⎢- ─────── + ──────  -sin(θ)  0⎥\n⎢   cos(θ)   cos(θ)            ⎥\n⎢                              ⎥\n⎢      sin(θ)        cos(θ)   0⎥\n⎢                              ⎥\n⎣        0              0     1⎦"},"exec_count":3,"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":30,"id":"f5db65","input":"N = me.ReferenceFrame('N')\nA = me.ReferenceFrame('A')\n\nq_0, qi, qj, qk = sm.symbols('q_0 q_i q_j q_k')\nq = (q_0, qi, qj, qk)\nA.orient_quaternion(N, q)\nA.dcm(N)","output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}q_{0}^{2} + q_{i}^{2} - q_{j}^{2} - q_{k}^{2} & 2 q_{0} q_{k} + 2 q_{i} q_{j} & - 2 q_{0} q_{j} + 2 q_{i} q_{k}\\\\- 2 q_{0} q_{k} + 2 q_{i} q_{j} & q_{0}^{2} - q_{i}^{2} + q_{j}^{2} - q_{k}^{2} & 2 q_{0} q_{i} + 2 q_{j} q_{k}\\\\2 q_{0} q_{j} + 2 q_{i} q_{k} & - 2 q_{0} q_{i} + 2 q_{j} q_{k} & q_{0}^{2} - q_{i}^{2} - q_{j}^{2} + q_{k}^{2}\\end{matrix}\\right]$","text/plain":"⎡  2     2      2     2                                                ⎤\n⎢q₀  + qᵢ  - q_j  - qₖ     2⋅q₀⋅qₖ + 2⋅qᵢ⋅q_j     -2⋅q₀⋅q_j + 2⋅qᵢ⋅qₖ  ⎥\n⎢                                                                      ⎥\n⎢                          2     2      2     2                        ⎥\n⎢ -2⋅q₀⋅qₖ + 2⋅qᵢ⋅q_j    q₀  - qᵢ  + q_j  - qₖ     2⋅q₀⋅qᵢ + 2⋅q_j⋅qₖ  ⎥\n⎢                                                                      ⎥\n⎢                                                  2     2      2     2⎥\n⎣  2⋅q₀⋅q_j + 2⋅qᵢ⋅qₖ     -2⋅q₀⋅qᵢ + 2⋅q_j⋅qₖ    q₀  - qᵢ  - q_j  + qₖ ⎦"},"exec_count":30,"output_type":"execute_result"}},"pos":60,"type":"cell"}
{"cell_type":"code","exec_count":31,"id":"8b6792","input":"q = (sm.cos(theta/2), sm.sin(theta/2), 0, 0)\nA.orient_quaternion(N, q)\nsm.trigsimp(A.dcm(N))","output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)}\\\\0 & - \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)}\\end{matrix}\\right]$","text/plain":"⎡1     0       0   ⎤\n⎢                  ⎥\n⎢0  cos(θ)   sin(θ)⎥\n⎢                  ⎥\n⎣0  -sin(θ)  cos(θ)⎦"},"exec_count":31,"output_type":"execute_result"}},"pos":62,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"1afba2","input":"sm.trigsimp(A_C_N.inv())","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:17.990346Z","iopub.status.busy":"2023-06-28T09:21:17.990094Z","iopub.status.idle":"2023-06-28T09:21:18.127343Z","shell.execute_reply":"2023-06-28T09:21:18.126437Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & - \\sin{\\left(\\theta \\right)} & 0\\\\\\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(θ)  -sin(θ)  0⎤\n⎢                  ⎥\n⎢sin(θ)  cos(θ)   0⎥\n⎢                  ⎥\n⎣  0        0     1⎦"},"exec_count":4,"output_type":"execute_result"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"779694","input":"A_C_N.transpose()","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.130889Z","iopub.status.busy":"2023-06-28T09:21:18.130402Z","iopub.status.idle":"2023-06-28T09:21:18.137726Z","shell.execute_reply":"2023-06-28T09:21:18.136813Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & - \\sin{\\left(\\theta \\right)} & 0\\\\\\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(θ)  -sin(θ)  0⎤\n⎢                  ⎥\n⎢sin(θ)  cos(θ)   0⎥\n⎢                  ⎥\n⎣  0        0     1⎦"},"exec_count":5,"output_type":"execute_result"}},"pos":13,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"06c4cf","input":"A_C_N","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.141874Z","iopub.status.busy":"2023-06-28T09:21:18.141407Z","iopub.status.idle":"2023-06-28T09:21:18.148293Z","shell.execute_reply":"2023-06-28T09:21:18.147463Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(θ)   sin(θ)  0⎤\n⎢                  ⎥\n⎢-sin(θ)  cos(θ)  0⎥\n⎢                  ⎥\n⎣   0       0     1⎦"},"exec_count":6,"output_type":"execute_result"}},"pos":18,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"a493b8","input":"alpha = sm.symbols('alpha')\n\nB_C_A = sm.Matrix([[sm.cos(alpha), sm.sin(alpha), 0],\n                   [-sm.sin(alpha), sm.cos(alpha), 0],\n                   [0, 0, 1]])\n\nB_C_A","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.152357Z","iopub.status.busy":"2023-06-28T09:21:18.151735Z","iopub.status.idle":"2023-06-28T09:21:18.161142Z","shell.execute_reply":"2023-06-28T09:21:18.160344Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\alpha \\right)} & \\sin{\\left(\\alpha \\right)} & 0\\\\- \\sin{\\left(\\alpha \\right)} & \\cos{\\left(\\alpha \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(α)   sin(α)  0⎤\n⎢                  ⎥\n⎢-sin(α)  cos(α)  0⎥\n⎢                  ⎥\n⎣   0       0     1⎦"},"exec_count":7,"output_type":"execute_result"}},"pos":19,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"f3c28c","input":"B_C_N = B_C_A * A_C_N\nB_C_N","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.164009Z","iopub.status.busy":"2023-06-28T09:21:18.163763Z","iopub.status.idle":"2023-06-28T09:21:18.179528Z","shell.execute_reply":"2023-06-28T09:21:18.178726Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}- \\sin{\\left(\\alpha \\right)} \\sin{\\left(\\theta \\right)} + \\cos{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} + \\sin{\\left(\\theta \\right)} \\cos{\\left(\\alpha \\right)} & 0\\\\- \\sin{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} - \\sin{\\left(\\theta \\right)} \\cos{\\left(\\alpha \\right)} & - \\sin{\\left(\\alpha \\right)} \\sin{\\left(\\theta \\right)} + \\cos{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡-sin(α)⋅sin(θ) + cos(α)⋅cos(θ)  sin(α)⋅cos(θ) + sin(θ)⋅cos(α)   0⎤\n⎢                                                                 ⎥\n⎢-sin(α)⋅cos(θ) - sin(θ)⋅cos(α)  -sin(α)⋅sin(θ) + cos(α)⋅cos(θ)  0⎥\n⎢                                                                 ⎥\n⎣              0                               0                 1⎦"},"exec_count":8,"output_type":"execute_result"}},"pos":20,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"d699f9","input":"sm.trigsimp(B_C_N)","metadata":{"execution":{"iopub.execute_input":"2023-06-28T09:21:18.182303Z","iopub.status.busy":"2023-06-28T09:21:18.182065Z","iopub.status.idle":"2023-06-28T09:21:18.362705Z","shell.execute_reply":"2023-06-28T09:21:18.361865Z"}},"output":{"0":{"data":{"text/latex":"$\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\alpha + \\theta \\right)} & \\sin{\\left(\\alpha + \\theta \\right)} & 0\\\\- \\sin{\\left(\\alpha + \\theta \\right)} & \\cos{\\left(\\alpha + \\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]$","text/plain":"⎡cos(α + θ)   sin(α + θ)  0⎤\n⎢                          ⎥\n⎢-sin(α + θ)  cos(α + θ)  0⎥\n⎢                          ⎥\n⎣     0           0       1⎦"},"exec_count":9,"output_type":"execute_result"}},"pos":22,"type":"cell"}
{"cell_type":"markdown","id":"067cd8","input":"Проделаем все это в «sympy»:","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"0f3eb4","input":"Еще один часто используемый подход к представлению ориентаций основан на том, что называются [кватернионами](https://en.wikipedia.org/wiki/Quaternion). \n\nКватернионы похожи на мнимые числа, но с тремя мнимыми константами: i, j и k. \n\n$i^2 = j^2 = k^2 = ijk = -1$","pos":59,"type":"cell"}
{"cell_type":"markdown","id":"108e42","input":"Вот ее базовые вектора (ради этой красивой картинки мы и хакали базовый класс)","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"192e0e","input":"### Простые ориентации\n\nНачнем с двух систем отсчета `N` и `A` в которым системы юнит-векторовы изначально выравнены, а затем, повернем систему координат `A` на угол $\\theta$ относительно общей оси `z`:\n\n![](figures/orientation-simple.svg)\n\nИз приведенного выше рисунка можно вывести: \n\n$$\n   \\begin{bmatrix}\n     \\hat{a}_x \\\\\n     \\hat{a}_y \\\\\n     \\hat{a}_z\n   \\end{bmatrix}\n   =\n   \\begin{bmatrix}\n     \\cos{\\theta} & \\sin{\\theta} & 0 \\\\\n     -\\sin{\\theta} & \\cos{\\theta} & 0 \\\\\n     0 &  0  & 1\n   \\end{bmatrix}\n   \\begin{bmatrix}\n     \\hat{n}_x \\\\\n     \\hat{n}_y \\\\\n     \\hat{n}_z\n   \\end{bmatrix}\n$$\n\nЭта матрица однозначно описывает ориентацию между двумя системами отсчета, и поэтому мы даем ей собственное обозначение: \n\n$$\n   \\begin{bmatrix}\n     \\hat{a}_x \\\\\n     \\hat{a}_y \\\\\n     \\hat{a}_z\n   \\end{bmatrix}\n   =\n   {}^A\\mathbf{C}^N\n   \\begin{bmatrix}\n     \\hat{n}_x \\\\\n     \\hat{n}_y \\\\\n     \\hat{n}_z\n   \\end{bmatrix}\n$$","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"1bb262","input":"### Кватернионы\n","pos":58,"type":"cell"}
{"cell_type":"markdown","id":"25f1a4","input":"### Матрицы поворота (*матрицы направляющих косинусов*)\n\nТеперь определим матрицу для произвольной ориентации, см. рис.\n\n![](figures/orientation-three-angles.svg)\n\nАналогично прошлому примеру, мы можем написать:\n\n$$\n\\begin{align*}\n   \\hat{a}_x & = \\cos\\alpha_{xx} \\hat{n}_x +\\cos\\alpha_{xy} \\hat{n}_y + \\cos\\alpha_{xz} \\hat{n}_z \\\\\n   \\hat{a}_y & = \\cos\\alpha_{yx} \\hat{n}_x +\\cos\\alpha_{yy} \\hat{n}_y + \\cos\\alpha_{yz} \\hat{n}_z \\\\\n   \\hat{a}_z & = \\cos\\alpha_{zx} \\hat{n}_x +\\cos\\alpha_{zy} \\hat{n}_y + \\cos\\alpha_{zz} \\hat{n}_z\n\\end{align*} \n$$\n\nПоскольку мы работаем с единичными векторами, косинус угла между парой векторов это скалярное произведение: \n\n\n$$\n\\begin{align*}\n\\hat{a}_x = (\\hat{a}_x \\cdot \\hat{n}_x) \\hat{n}_x + (\\hat{a}_x \\cdot \\hat{n}_y) \\hat{n}_y + (\\hat{a}_x \\cdot \\hat{n}_z) \\hat{n}_z \\\\\n   \\hat{a}_y = (\\hat{a}_y \\cdot \\hat{n}_x) \\hat{n}_x + (\\hat{a}_y \\cdot \\hat{n}_y) \\hat{n}_y + (\\hat{a}_y \\cdot \\hat{n}_z) \\hat{n}_z \\\\\n   \\hat{a}_x = (\\hat{a}_z \\cdot \\hat{n}_x) \\hat{n}_x + (\\hat{a}_z \\cdot \\hat{n}_y) \\hat{n}_y + (\\hat{a}_z \\cdot \\hat{n}_z) \\hat{n}_z \\\\\n\\end{align*}\n$$\n\n$$\n   \\begin{bmatrix}\n     \\hat{a}_x \\\\\n     \\hat{a}_y \\\\\n     \\hat{a}_z\n   \\end{bmatrix}\n   =\n   {}^A\\mathbf{C}^N\n   \\begin{bmatrix}\n     \\hat{n}_x \\\\\n     \\hat{n}_y \\\\\n     \\hat{n}_z\n   \\end{bmatrix}\n$$\n\nгде\n$$\n  {}^A\\mathbf{C}^N\n   =\n   \\begin{bmatrix}\n     \\hat{a}_x \\cdot \\hat{n}_x &\\hat{a}_x \\cdot \\hat{n}_y & \\hat{a}_x \\cdot \\hat{n}_z \\\\\n     \\hat{a}_y \\cdot \\hat{n}_x &\\hat{a}_y \\cdot \\hat{n}_y & \\hat{a}_y \\cdot \\hat{n}_z \\\\\n     \\hat{a}_z \\cdot \\hat{n}_x &\\hat{a}_z \\cdot \\hat{n}_y & \\hat{a}_z \\cdot \\hat{n}_z\n   \\end{bmatrix}\n$$\n\n${}^A\\mathbf{C}^N$ — «матрица поворота» («матрица направляющего косинуса», «матрица вращения»). \n\nВ общем виде описание взаимной ориентации двух систем отсчета. Эта матрица однозначно определяет относительную ориентацию между системами отсчета `N` и `A``, она обратима, и ее инверсия равна транспонированию, так как показано выше на простом примере. \n\nОпределитель матрицы также всегда равен 1, чтобы гарантировать, что обе связанных системы отсчета являются правыми. ","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"35155d","input":"SymPy может найти эту обратную матрицу: ","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"484f1d","input":"Как показано выше, SymPy прекрасно справляется с матрицами вращений, в SymPy есть еще более полезный инструмент для отслеживания ориентации систем отсчета.\n\nМодуль `sympy.physics.mechanics` модуль включает в себя множество объектов и функций, которые упрощают учет и понятия,динамики и кинематики.","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"561156","input":"Можно сориентировать явным образом, используя полученные ранее матрицы поворота","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"5924ab","input":"Вот так можно наоборот, спросить матрицу поворота между любыми системами координат:","pos":37,"type":"cell"}
{"cell_type":"markdown","id":"5a2372","input":"Когда все промежуточные ориентации определены, можно запросить отношение ${}^D\\mathbf{C}^A$ камеры «D» относительно системы рукояток «A»: ","pos":54,"type":"cell"}
{"cell_type":"markdown","id":"5d1651","input":"SymPy также может найти транспонирование этой матрицы:","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"617bd9","input":"Длина кватерниона равна квадратному корню из суммы квадратов его компоненты. Для кватерниона, представляющего ориентацию, эта длина всегда должна быть равна 1.\n\nОказывается, правила умножения для (единичных) кватернионов дают эффективный способ составить несколько вращений и численно интегрировать ориентация при заданной угловой скорости. \n\nИз-за интерпретации, связанной с представлением угла и оси, это также несколько интуитивное представление. \n\nОднако алгоритм интеграции должен сделать дополнительный шаг, чтобы гарантировать кватернион всегда имеет единичную длину.\n\nПредставление ориентаций вообще оказывается связанным с область математики, называемая группами Ли. Теория групп Ли имеет дальнейшие приложения к механике, и заинтересованный читатель может использовать статью [группу 3D-вращения](https://en.wikipedia.org/wiki/3D_rotation_group) как отправную точку для дальнейшего изучения.","pos":63,"type":"cell"}
{"cell_type":"markdown","id":"6c7323","input":"Примечательно, что инверсия и транспонирование здесь одинаковы. Это потому, что эта матрица является [ортогональной](https://en.wikipedia.org/wiki/Orthogonal_matrix), и все матрицы, описывающие ориентацией между системами отсчета являются ортогональными. \n\nТак что будет выполнятся:\n\n$$\n   {}^N\\mathbf{C}^A = \\left({}^A\\mathbf{C}^N\\right)^{-1} = \\left({}^A\\mathbf{C}^N\\right)^T\n$$","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"6f1bf6","input":"### Последовательные ориентации\n\nПоследовательная ориентация серии систем отсчета часто бывают более удобны, чем одна сложная матрица поворота. \n\nЗаведем еще систему отсчета `B`, которая ориентирована относительно `A`, примерно так же, как `A` ранее, относительно `N`:\n\n![](figures/orientation-simple-successive.svg)\n\nИз \n$$\n   \\begin{bmatrix}\n     \\hat{a}_x \\\\\n     \\hat{a}_y \\\\\n     \\hat{a}_z\n   \\end{bmatrix}\n   =\n   {}^A\\mathbf{C}^N\n   \\begin{bmatrix}\n     \\hat{n}_x \\\\\n     \\hat{n}_y \\\\\n     \\hat{n}_z\n   \\end{bmatrix}\n$$\nи \n\n$$\n   \\begin{bmatrix}\n     \\hat{b}_x \\\\\n     \\hat{b}_y \\\\\n     \\hat{b}_z\n   \\end{bmatrix}\n   =\n   {}^B\\mathbf{C}^A\n   \\begin{bmatrix}\n     \\hat{a}_x \\\\\n     \\hat{a}_y \\\\\n     \\hat{a}_z\n   \\end{bmatrix}\n$$\n\nподстановкой, мы получим:\n\n$$\n   \\begin{bmatrix}\n     \\hat{b}_x \\\\\n     \\hat{b}_y \\\\\n     \\hat{b}_z\n   \\end{bmatrix}\n   =\n   {}^B\\mathbf{C}^A\n   {}^A\\mathbf{C}^N\n   \\begin{bmatrix}\n     \\hat{n}_x \\\\\n     \\hat{n}_y \\\\\n     \\hat{n}_z\n   \\end{bmatrix}\n$$\n\nт.е. матрица поворота между `B` и `N` получается в результате матричного умножения соответствующих промежуточных матриц поворота.\n\n$$\n   {}^B\\mathbf{C}^N\n   =\n   {}^B\\mathbf{C}^A\n   {}^A\\mathbf{C}^N\n$$\n\nЭто справедливо для любой серии общих трехмерных последовательных ориентаций, согласно теореме: \n\n$$\n   {}^Z\\mathbf{C}^A\n   =\n   {}^Z\\mathbf{C}^Y\n   {}^Y\\mathbf{C}^X\n   \\ldots\n   {}^C\\mathbf{C}^B\n   {}^B\\mathbf{C}^A\n$$","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"73891c","input":"Благодаря этим трем последовательным ориентациям камеру можно вращать произвольно. относительно рамки рукоятки. Эти последовательные «z»→«x»→«y» ориентации являются стандартным способом описания взаимоориентации двух систем отсчета и называются [углами Эйлера](https://en.wikipedia.org/wiki/Euler_angles)\n\nСуществует 12 допустимых наборов последовательных ориентаций,\n* шесть «правильных эйлеровых углов»: «z-x-z», «x-y-x», «y-z-y», «z-y-z», «x-z-x» , «y-x-y»\n* шесть «углов Тейта-Брайана»: «x-y-z», «y-z-x», «z-x-y», «x-z-y», «z-y-x», «y-x-z»\n\n----\n![](https://upload.wikimedia.org/wikipedia/commons/8/85/Euler2a.gif)\n\nОриентация по углам Эйлера с рамкой. «A» (синий), «B» (зеленый), «C» (желтый) и «D» (красный). \n* Правый синяя стрелка - это «x», \n* синяя стрелка влево — это «y», \n* синяя стрелка вверх — это «z». \n\nЕдиничные векторы всех кадров выравниваются перед ориентацией. \n\nНижний желтая стрелка в анимации должна быть зеленой, учитывая, что это обычное явление цветные стрелки должны быть ортогональны. \n\n----\n\nДля конкретной кинематической конструкции могут быть полезны разные варианты. \n\nС точки зрения ориентации, твердое тело и система отсчета — синонимы, так что вполне можно использовать «фиксированные ориентации тела». \n\nМетод [`orient_body_fixed()`](https://docs.sympy.org/latest/modules/physics/vector/api/classes.html#sympy.physics.vector.frame.ReferenceFrame.orient_body_fixed) может быть использован для установления связи между «A» и «D» без необходимости создания вспомогательных систем отсчета «B» и «C»:\n","pos":56,"type":"cell"}
{"cell_type":"markdown","id":"73d340","input":"Но есть и другие удобные методы, не требующие знания матрицы вращения. \n\nНапример, `orient_axis` позволяет естественно определять простые ориентации между системами отсчета, используя исходную систему, угол и вектор поворота. ","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"76169e","input":"### Углы Эйлера\n\n[Подвес стабилизации камеры](https://en.wikipedia.org/wiki/Gimbal) , показанный на рисунке имеет три [вращающиеся суставы](https://en.wikipedia.org/wiki/Revolute_joint), которые ориентируют камеру «D» относительно системы рукояток «A».\n\n![](figures/orientation-camera-gimbal.png)\n\n\nЕсли ввести две дополнительные вспомогательные системы отсчета, «B» и «C», мы можем использовать три последовательные простые ориентации для перехода от «A» к «D», и наша последовательность из трех ориентаций позволит нам ориентировать D любым возможным способом относительно A.\n\nПосмотрите [это видео](https://www.youtube.com/watch?v=xQMBIXqWcjI&t=177s), чтобы получить представление об осях ориентации каждого промежуточного звена. ","pos":47,"type":"cell"}
{"cell_type":"markdown","id":"8c0ddf","input":"Повторим нашу игру с системами `A`, `B`, `N`.\nПросто зададим их, никак сначала не ориентируя.","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"8f171a","input":"### Юнит-векторы \n\nВекторы имеют величину, направление и знак (±), но, не привязаны к какой-либо позиции. \n\nЮнит-векторы имеют величину 1. \nЮнит-векторы могут быть фиксированными, по ориентации, к системе отсчета. \n\nДля системы отсчета `N` мы определим три взаимно перпендикулярных единичных вектора\n$\\hat{n}_x$, $\\hat{n}_y$, $\\hat{n}_z$ (крышкой мы обозначаем единичные векторы), \n\nгде эти юнит-векторы связаны следующим «правым» [векторным произведением](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5):\n\n$$\n\\begin{align}\n   \\hat{n}_x \\times \\hat{n}_y & = \\hat{n}_z \\\\\n   \\hat{n}_y \\times \\hat{n}_z & = \\hat{n}_x \\\\\n   \\hat{n}_z \\times \\hat{n}_x & = \\hat{n}_y\n\\end{align}\n$$","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"91ce4d","input":"Вращение на угол θ вокруг единичного вектора $\\hat{e}$ может быть преобразовано в представление кватернионов, имея \n$q_0 = \\cos\\left(\\frac{\\theta}{2}\\right)$\nи $\\sin\\left(\\frac{\\theta}{2}\\right)$ вокруг компоненты оси вращение. \n\nНапример, если ось вращения $\\hat{n}_x$, мы получаем:","pos":61,"type":"cell"}
{"cell_type":"markdown","id":"925399","input":"После прочтения этой главы вы сможете:\n- Определить \n    * систему отсчета со связанными единичными векторами.\n    * матрицу направляющего косинуса между двумя ориентированными системами отсчета.\n\n- Вывести матрицы направляющих косинусов для простых и последовательных вращений.\n\n- Управлять матрицами косинусов ориентации и направления с помощью SymPy.\n\n- Вращать системы отсчета, используя углы Эйлера.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"937517","input":"Чтобы не пугаться, сразу попросим упростить:","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"a7d9e9","input":"Изображения слева и справа представляют один и тот же набор взаимно перпендикулярные единичные векторов. \n\n![](figures/orientation-vector-position.svg)\n\nВекторы, как правило, не имеют положение и может быть нарисовано в любом месте системы отсчета. Для удобства их рисуют исходящими из одной точки. \n","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"bd0e1e","input":"Добавим небольшой хак, переопределив оригинальный класс, чтобы был более красивый вывод с формулами для образовательных целей (можно не обращать внимания при первом чтении).\n\nВажная штука — эту ячейку нужно вызвать ровно один раз иначе будет рекурсия (что-то с этим надо сделать)","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"c0b551","input":"## Механика SymPy\n","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"ce0cdd","input":"Мы сначала ориентируем B относительно A вращением на угол ψ относительно вектора z: \n\n![](figures/orientation-gimbal-psi.svg)","pos":48,"type":"cell"}
{"cell_type":"markdown","id":"d2ca7f","input":"Теперь ориентируем C относительно B вращая угол θ через общий вектор x\n\n![](figures/orientation-gimbal-theta.svg)","pos":50,"type":"cell"}
{"cell_type":"markdown","id":"dfc10a","input":"И наконец, сориентируем камеру D, вращая на угол ϕ относительно C через общий единичный вектор «y». \n\n![](figures/orientation-gimbal-phi.svg)","pos":52,"type":"cell"}
{"cell_type":"markdown","id":"e0500e","input":"## ReferenceFrame — система отсчета / координат.\n\nПри изучении динамики тел (связанных и взаимодействующих объектов в трехмерном пространстве), обычно нас интересует наблюдение их движения. Это наблюдение требует понятие систем отсчета. \n\n*Система отсчета* — это абстракция, которую мы определяем как набор всех точек в [евклидовом пространстве](https://en.wikipedia.org/wiki/Euclidean_space), которые фиксируются наблюдателем любого данного состояние движения. \n\nС практической точки зрения полезно представить свой глаз как наблюдатель — глаз может ориентироваться в трехмерном пространстве, чтобы увидеть движение объектов с любого направления, и движение объектов будет проявляться по-разному в наборе точек, связанных с системой отсчета, прикрепленной к вашему глазу в зависимости от ориентации вашего глаза.\n\nВажно отметить, что система отсчета не эквивалентна системе координат, ведь можно использовать любое количество систем координат (декартовых или сферический) для описания движения точек или объектов в пространстве. \n\n`ReferenceFrame` — cистема координат с измерением.  \nБудем характеризовать систему отсчета [правым](https://en.wikipedia.org/wiki/Right-hand_rule) множеством взаимно перпендикулярных единичных векторов, которые можно использовать для описания его ориентацию относительно других систем отсчета, и мы выровняем декартову система координат с единичными векторами, позволяющая легко измерять точки неподвижно или перемещается в системе отсчета.","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"e4c457","input":"Чтобы создать систему отсчета, используем этот класс, задав название этой системы обычной строкой: ","pos":28,"type":"cell"}
{"cell_type":"markdown","id":"f20da6","input":"Упрощение этих тригонометрических выражений показывает ожидаемый результат: ","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"f2384e","input":"Если нам нужна обратная зависимость между двумя наборами единичных векторов и ${}^A\\mathbf{C}^N$ обратима, то:\n\n$$\n\\begin{bmatrix}\n     \\hat{n}_x \\\\\n     \\hat{n}_y \\\\\n     \\hat{n}_z\n   \\end{bmatrix}\n   =\n   \\left({}^A\\mathbf{C}^N\\right)^{-1}\n   \\begin{bmatrix}\n     \\hat{a}_x \\\\\n     \\hat{a}_y \\\\\n     \\hat{a}_z\n   \\end{bmatrix}\n$$","pos":7,"type":"cell"}
{"id":0,"time":1704864337196,"type":"user"}
{"last_load":1704864338426,"type":"file"}